---
published: true
layout: post
title: How I Studied Algorithms
summary: From "systems guy" to "systems guy with healthy respect for theory"
---

In Spring 2013, I took Purdue CS's required graduate level Algorithms course. It was a lot of work, but I did pretty well, especially considering my background is in the less theoretical field of Computer Engineering.

At first when I was trying to understand a new algorithm, I'd code it up in my favorite language (Python).  This works OK for the simpler algorithms like sorting, but for some of the esoteric topics (*ahem* [Fibonacci Heaps](http://en.wikipedia.org/wiki/Fibonacci_heap ) *ahem*) I'd end up spending more time coding than answering homework problems.

Another technique I used was working out an example on paper.  That only works for a very specific subset of algorithms.  The obstacle is representing the state of the algorithm in writing in a concise way.  It's easy to write a whole lot and not get through a small example.  But there were some problems for which a small example or diagram sparked an idea that eventually led me to a solution.

Studying some algorithms forces the student to run the algorithm through in their head.  This is great practice for my "brain debugger" -- finding a bug by mentally stepping through the code.  It's a skill that is invaluable for any programmer, and a good reason to study algorithms even if you have no interest in theory.

The most important trait when studying algorithms is the ability to work on a problem without finding the solution for a long period of time without getting frustrated.  For example, say I'm working through an exam and I turn the page and read the next problem, but I have no idea how to do it.  The worst thing I could do is panic or get frustrated, but that comes naturally to a student who is used to getting the correct answer easily.  Sometimes the only thing to do is brainstorm: make diagrams, do a small example, etc, and be prepared to throw away ideas that aren't going to work out.  That's research in a nutshell.  The answers to hard, interesting problems aren't obvious or someone would have already found it.
